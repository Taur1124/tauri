// Copyright 2019-2023 Tauri Programme within The Commons Conservancy
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT

use super::{detect_target_ok, ensure_init, env, with_config, CliOptions, MobileTarget};
use crate::Result;
use anyhow::Context;
use clap::{ArgAction, Parser};

use tauri_mobile::{
  android::{
    config::{Config as AndroidConfig, Metadata as AndroidMetadata},
    env::Env,
    target::Target,
  },
  opts::Profile,
  target::{call_for_targets_with_fallback, TargetTrait},
};

use std::{
  fs::{read_dir, read_to_string, write},
  path::PathBuf,
};

#[derive(Debug, Default, Parser)]
pub struct Options {
  /// Targets to build.
  #[clap(
    short,
    long = "target",
    action = ArgAction::Append,
    num_args(0..),
    default_value = Target::DEFAULT_KEY,
    value_parser(clap::builder::PossibleValuesParser::new(Target::name_list()))
  )]
  pub targets: Option<Vec<String>>,
  /// Builds with the release flag
  #[clap(short, long)]
  pub release: bool,
}

pub fn command(options: Options) -> Result<()> {
  let profile = if options.release {
    Profile::Release
  } else {
    Profile::Debug
  };

  with_config(None, |_app, config, metadata, cli_options| {
    ensure_init(config.project_dir(), MobileTarget::Android)?;
    let env = env()?;
    run(
      config,
      metadata,
      &cli_options,
      &env,
      options.targets.unwrap_or_default(),
      profile,
    )
  })
}

pub fn run(
  config: &AndroidConfig,
  metadata: &AndroidMetadata,
  cli_options: &CliOptions,
  env: &Env,
  targets: Vec<String>,
  profile: Profile,
) -> Result<()> {
  call_for_targets_with_fallback(targets.iter(), &detect_target_ok, env, |target: &Target| {
    target
      .build(
        config,
        metadata,
        env,
        cli_options.noise_level,
        true,
        profile,
      )
      .map_err(|e| anyhow::anyhow!(e.to_string()))
  })
  .map_err(|e| anyhow::anyhow!(e.to_string()))??;

  generate_gradle_files(config.project_dir())?;

  Ok(())
}

fn generate_gradle_files(project_dir: PathBuf) -> Result<()> {
  let gradle_settings_path = project_dir.join("tauri.settings.gradle");
  let app_build_gradle_path = project_dir.join("app").join("tauri.build.gradle.kts");

  let mut gradle_settings =
    "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.\n".to_string();
  let mut app_build_gradle = "// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
val implementation by configurations
dependencies {"
    .to_string();

  let plugin_output_folder = project_dir.join(".tauri").join("plugins");

  for entry in read_dir(plugin_output_folder)? {
    let entry = entry?;
    let plugin_name = entry
      .path()
      .file_name()
      .unwrap()
      .to_string_lossy()
      .into_owned();
    let plugin_path = read_to_string(entry.path())?;

    gradle_settings.push_str(&format!("include ':{plugin_name}'"));
    gradle_settings.push('\n');
    gradle_settings.push_str(&format!(
      "project(':{plugin_name}').projectDir = new File({:?})",
      tauri_utils::display_path(plugin_path)
    ));
    gradle_settings.push('\n');

    app_build_gradle.push('\n');
    app_build_gradle.push_str(&format!(r#"  implementation(project(":{plugin_name}"))"#));
  }

  app_build_gradle.push_str("\n}");

  write(gradle_settings_path, gradle_settings).context("failed to write tauri.settings.gradle")?;

  write(app_build_gradle_path, app_build_gradle)
    .context("failed to write tauri.build.gradle.kts")?;

  Ok(())
}
