// Copyright 2019-2021 Tauri Programme within The Commons Conservancy
// SPDX-License-Identifier: Apache-2.0
// SPDX-License-Identifier: MIT

use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use syn::{
  parse::Parser, punctuated::Punctuated, FnArg, Ident, ItemFn, Pat, Path, ReturnType, Token, Type,
  Visibility,
};

/// The autogenerated wrapper ident
fn fn_wrapper(function: &Ident) -> Ident {
  format_ident!("__cmd__{}", function)
}

/// Automatically insert await when the command we are wrapping is async
fn maybe_await(function: &ItemFn) -> TokenStream {
  match function.sig.asyncness {
    Some(_) => quote!(.await),
    None => Default::default(),
  }
}

/// If the autogenerated wrapper needs to be explicitly exported (if the function is pub)
fn maybe_export(function: &ItemFn) -> (&Visibility, TokenStream) {
  (
    &function.vis,
    match &function.vis {
      Visibility::Public(_) => quote!(#[macro_export]),
      _ => Default::default(),
    },
  )
}

/// Generate a minimal skeleton with all the required items named but unimplemented.
///
/// Prevents extraneous errors when some item inside the macro errors.
fn err(function: ItemFn, error_message: &str) -> TokenStream {
  let wrap = fn_wrapper(&function.sig.ident);
  let (vis, maybe_export) = maybe_export(&function);
  quote! {
    #function

    #maybe_export
    macro_rules! #wrap {
      ($path:path, $invoke:ident) => {{
        compile_error!(#error_message);
        unimplemented!()
      }};
    }

    #vis use #wrap;
  }
}

pub fn generate_command(function: ItemFn) -> TokenStream {
  let fn_name = function.sig.ident.clone();
  let fn_wrapper = fn_wrapper(&fn_name);
  let (vis, maybe_export) = maybe_export(&function);
  let maybe_await = maybe_await(&function);

  // todo: detect command return types automatically like params, removes parsing type name
  let returns_result = match function.sig.output {
    ReturnType::Type(_, ref ty) => match &**ty {
      Type::Path(type_path) => {
        type_path
          .path
          .segments
          .first()
          .map(|seg| seg.ident.to_string())
          == Some("Result".to_string())
      }
      _ => false,
    },
    ReturnType::Default => false,
  };

  let args: Result<Vec<_>, _> = function
    .sig
    .inputs
    .iter()
    .map(|param| {
      // todo: clean up this error logic later by wrapping the function in a result and having a
      // dedicated error type
      let arg = match param {
        FnArg::Typed(arg) => match arg.pat.as_ref() {
          Pat::Ident(arg) => {
            if arg.ident == "self" {
              return Err(err(
                function.clone(),
                "unable to use self as a command function parameter",
              ));
            } else {
              arg.ident.clone()
            }
          }
          _ => {
            return Err(err(
              function.clone(),
              "command parameters expected to be a typed pattern",
            ))
          }
        },
        FnArg::Receiver(_) => {
          return Err(err(
            function.clone(),
            "unable to use self as a command function parameter",
          ))
        }
      };

      Ok(quote!(::tauri::command::CommandArg::from_command(
        ::tauri::command::CommandItem {
          name: stringify!(#fn_name),
          key: stringify!(#arg),
          message: &message,
        }
      )))
    })
    .collect();

  // we have no way to recover if we didn't successfully parse the arguments, return compile error
  let args = match args {
    Ok(args) => args,
    Err(err) => return err,
  };

  // todo: change this to automatically detect result returns (see above result todo)
  // if the command handler returns a Result,
  // we just map the values to the ones expected by Tauri
  // otherwise we wrap it with an `Ok()`, converting the return value to tauri::InvokeResponse
  // note that all types must implement `serde::Serialize`.
  let return_value = if returns_result {
    quote! {
      let result = $path(#(#args?),*);
      ::core::result::Result::Ok(result #maybe_await?)
    }
  } else {
    quote! {
      let result = $path(#(#args?),*);
      ::core::result::Result::<_, ::tauri::InvokeError>::Ok(result #maybe_await)
    }
  };

  quote! {
    #function

    #[doc(hidden)]
    #maybe_export
    macro_rules! #fn_wrapper {
      ($path:path, $invoke:ident) => {{
        #[allow(unused_variables)]
        let ::tauri::Invoke { message, resolver } = $invoke;

        resolver.respond_async(async move {
          #return_value
        });
      }};
    }

    #[doc(hidden)]
    #vis use #fn_wrapper;
  }
}

pub fn generate_handler(item: proc_macro::TokenStream) -> TokenStream {
  // Get paths of functions passed to macro
  let paths = <Punctuated<Path, Token![,]>>::parse_terminated
    .parse(item)
    .expect("generate_handler!: Failed to parse list of command functions");

  // Get names of functions, used for match statement
  let fn_names = paths
    .iter()
    .map(|p| p.segments.last().unwrap().ident.to_string());

  // Get paths to wrapper functions
  let fn_wrappers = paths.iter().map(|func| {
    let mut func = func.clone();
    let mut last_segment = func.segments.last_mut().unwrap();
    last_segment.ident = fn_wrapper(&last_segment.ident);
    func
  });

  // turn it into an iterator so that `Punctuated` will only output the paths
  let paths = paths.iter();

  quote! {
    move |invoke| {
      let cmd = invoke.message.command();
      match cmd {
        #(#fn_names => #fn_wrappers!(#paths, invoke),)*
        _ => {
          invoke.resolver.reject(format!("command {} not found", cmd))
        },
      }
    }
  }
}
